## What this is

A React app that simulates how personal influence spreads through a stylized social network. The goal is to make the gap between linear and exponential intuition viscerally visible, not to predict real-world outcomes. Story-first, honest about limitations.

## Stack

| Layer           | Tech                                                                        |
| --------------- | --------------------------------------------------------------------------- |
| Frontend        | React 19, TypeScript, Tailwind CSS v4, Recharts                             |
| Build           | Vite 7 (with `vite-plugin-wasm` + `vite-plugin-top-level-await`)            |
| Simulation      | Rust → WASM via `wasm-bindgen` / `wasm-pack`                                |
| Threading       | Web Worker (`simulation.worker.ts`) offloads simulation off the main thread |
| Package manager | `pnpm`                                                                      |

## Key files

```
src/
  types.ts              — SimParams, SimResult, Status interfaces
  simulation.ts         — TypeScript simulation (reference / fallback, not currently used)
  simulation_wasm.ts    — Thin TS wrapper around the WASM export
  simulation.worker.ts  — Web Worker: receives "run" message, calls WASM, posts back progress/result
  lib.rs                — Rust simulation (the live implementation, compiled to WASM)
  App.tsx               — Original open-ended tool (edit influence/population/etc, see full results)
  AppV2.tsx             — Guided tutorial mode; swap into main.tsx to activate
  components/           — Pure-ish presentational components for App.tsx
  tutorial/             — All tutorial-mode code (see below)
  wasm-sim/             — Generated by wasm-pack; do not edit by hand
```

### Tutorial system (`src/tutorial/`)

```
tutorial/
  types.ts              — TutorialStepDef (discriminated union), OverrideProps,
                          ResultProps, GuessInputConfig
  TutorialShell.tsx     — Progress-dot indicator; mounts fullOverride OR StepRunner
  StepRunner.tsx        — All shared mechanics: guess input, submit, loading bar,
                          guess-vs-actual reveal cards, Result mount, nav buttons
  visualizers/          — Reusable visualizer components (imported by Result components)
    YearByYearBreakdown.tsx
  steps/
    index.ts            — Ordered step registry — THE ONLY FILE to edit when adding a step
    Intro.tsx           — fullOverride step (no sim; just intro text + CTA)
    Step1_TwoPeople.tsx — Standard step: Prompt + guessInput config + Result
```

**To add a new standard tutorial step:**
1. Create `src/tutorial/steps/StepN_Name.tsx` exporting: `INFLUENCE_PER_YEAR`, `TUTORIAL_PARAMS`, `Prompt`, `guessInput`, `Result`.
2. Add one entry to `steps/index.ts`. Nothing else changes.

**To add a full-override step** (custom layout, no sim): export a component satisfying `OverrideProps` and register it with `{ label, fullOverride: YourComponent }`.

## Architecture in one sentence

**Original tool:** `App.tsx` posts a message to a Web Worker → the worker calls `runSimulateWasm` → progress and final `SimResult` are posted back → `App.tsx` updates state → `ResultsPanel` renders.

**Tutorial mode:** `AppV2.tsx` owns the same worker; it passes `runSim`/`resetSim` down to `TutorialShell` → `StepRunner`, which drives a fixed guess→reveal flow for each step. Step files contribute only their unique content (Prompt, guessInput config, Result); all scaffolding lives in `StepRunner`.

## Simulation logic

The active implementation lives in **`src/lib.rs`**. The TypeScript version in `simulation.ts` is a readable reference but is **not called at runtime**. When exploring simulation behaviour, read `lib.rs`.

Network model: each person has `avgConnections` peers; `withinRatio` fraction are "nearby" (sequential IDs) and the rest are random long-range bridges. Influence spreads BFS-style, year by year. Simulation ends when:
